# -*- coding: utf-8 -*-
"""LVADSUSR72-ARYAN_MITTAL-FA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lDDhbRiiC-6GZxE52Bs64xLUxkqmbOHN

# **Question1**
"""

import pandas as pd

df = pd.read_csv('/content/Walmart_Dataset Python_Final_Assessment.csv')
df.head()

df.shape

df.describe()

df.info()

"""# **Question2**"""

#Q2
df.isnull().sum()    #no null values

df.fillna(0)  #returns the same data

df.duplicated().sum()    #no duplicate entries
df.drop_duplicates()

"""# **Question3**"""

#q3
import numpy as np
from scipy import stats
numerical_columns = ['Sales', 'Quantity', 'Profit']

# Calculate measures
measures = {}
for col in numerical_columns:
    measures[col] = {
        'Mean': np.mean(df[col]),
        'Median': np.median(df[col]),
        'Mode': stats.mode(df[col]),
        'Range': np.max(df[col]) - np.min(df[col]),
        'Variance': np.var(df[col]),
        'Standard Deviation': np.std(df[col])
    }

# Display measures
for col, stats in measures.items():
    print(f"\nMeasures for column '{col}':")
    for measure, value in stats.items():
        print(f"{measure}: {value}")

"""# **Question4**"""

#q4
import matplotlib.pyplot as plt
import seaborn as sns

# Histograms for numerical columns
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
sns.histplot(df['Sales'], bins=20, kde=True, color='skyblue')
plt.title('Distribution of Sales')

plt.subplot(1, 3, 2)
sns.histplot(df['Quantity'], bins=20, kde=True, color='salmon')
plt.title('Distribution of Quantity')

plt.subplot(1, 3, 3)
sns.histplot(df['Profit'], bins=20, kde=True, color='green')
plt.title('Distribution of Profit')

plt.tight_layout()
plt.show()

# Scatter plot for Sales vs Profit
plt.figure(figsize=(8, 6))
sns.scatterplot(data=df, x='Sales', y='Profit', color='purple')
plt.title('Scatter plot of Sales vs Profit')
plt.xlabel('Sales')
plt.ylabel('Profit')
plt.show()

# Box plot for Profit by Category
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Category', y='Profit', palette='Set2')
plt.title('Box plot of Profit by Category')
plt.xticks(rotation=45)
plt.show()

# Bar chart for Category
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='Category', palette='muted')
plt.title('Bar chart of Category')
plt.xticks(rotation=45)
plt.show()

# Pie chart for Geography
plt.figure(figsize=(8, 8))
df['Geography'].value_counts().plot(kind='pie', autopct='%1.1f%%', colors=sns.color_palette('pastel'), startangle=90)
plt.title('Pie chart of Geography')
plt.ylabel('')
plt.show()

"""# **Question5**"""

# Selecting numerical columns
numerical_columns = ['Sales', 'Quantity', 'Profit']
print(df[numerical_columns])

# Calculate correlation matrix
correlation_matrix = df[numerical_columns].corr()

# Visualize correlation matrix using a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

"""By examining the heatmap, you can quickly identify which variables are positively or negatively correlated and to what extent. For example, if the correlation coefficient between Sales and Profit is close to 1, it indicates a strong positive correlation, suggesting that higher sales are associated with higher profits. Conversely, if the correlation coefficient between Sales and Quantity is close to 0, it suggests little to no linear relationship between these variables.

**INSIGHTS:**
Higher sales will lead to higher profits but sales and quantity are little correlated with each other, profit and quantity is very little to no correlated to each other , so we can say that rising of quantity doesnt effects rising profit.

# **Question6**
"""

# Summary statistics
summary_stats = df[['Sales', 'Quantity', 'Profit']].describe()
print(summary_stats)


# Define a function to detect outliers using the interquartile range (IQR)
def detect_outliers_iqr(column):
    Q1 = np.percentile(column, 25)
    Q3 = np.percentile(column, 75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = (column < lower_bound) | (column > upper_bound)
    return outliers

# Detect outliers in the numerical columns
outliers_sales = detect_outliers_iqr(df['Sales'])
outliers_quantity = detect_outliers_iqr(df['Quantity'])
outliers_profit = detect_outliers_iqr(df['Profit'])

# Display the number of outliers in each column
print("Number of outliers in Sales:", outliers_sales.sum())
print("Number of outliers in Quantity:", outliers_quantity.sum())
print("Number of outliers in Profit:", outliers_profit.sum())

# Box plot for numerical columns
plt.figure(figsize=(12, 6))
sns.boxplot(data=df[['Sales', 'Quantity', 'Profit']], palette='Set2')
plt.title('Box plot of Sales, Quantity, and Profit')
plt.xticks(rotation=45)
plt.show()

"""# **Question 7**

# Trend Analysis

To analyze the sales and profit trends over the years, we first need to convert the 'Order Date' column to a datetime format and extract the year from it. Then, we can group the data by year and calculate the total sales and profits for each year. Finally, we can visualize the trends using line plots.
"""

# Convert 'Order Date' to datetime format and extract the year
df['Order Date'] = pd.to_datetime(df['Order Date'])
df['Year'] = df['Order Date'].dt.year

# Group by year and calculate total sales and profits
yearly_sales = df.groupby('Year')['Sales'].sum()
yearly_profit = df.groupby('Year')['Profit'].sum()

# Plotting sales and profit trends over the years
plt.figure(figsize=(10, 6))
plt.plot(yearly_sales.index, yearly_sales.values, label='Sales', marker='o', color='blue')
plt.plot(yearly_profit.index, yearly_profit.values, label='Profit', marker='s', color='green')
plt.title('Sales and Profit Trends Over the Years')
plt.xlabel('Year')
plt.ylabel('Amount')
plt.legend()
plt.grid(True)
plt.xticks(yearly_sales.index)
plt.show()

"""To determine the product category that has shown the most growth in terms of sales over the years, we can calculate the total sales for each category in each year and then compare the growth rates between categories."""

# Group by year and category and calculate total sales
yearly_category_sales = df.groupby(['Year', 'Category'])['Sales'].sum().unstack()

# Plotting sales trends for each category over the years
plt.figure(figsize=(22, 9))
yearly_category_sales.plot(marker='o')
plt.title('Sales Trends for Each Category Over the Years')
plt.xlabel('Year')
plt.ylabel('Sales')
plt.legend(title='Category', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xticks(yearly_sales.index)
plt.grid(True)
plt.show()

# Extract year from 'Order Date' column
df['Year'] = df['Order Date'].dt.year

category_sales = df.groupby(['Year', 'Category'])['Sales'].sum().reset_index()

# Pivot the table to have years as rows, categories as columns, and total sales as values
category_sales_pivot = category_sales.pivot(index='Year', columns='Category', values='Sales')

# Calculate the sales growth rate for each category
category_sales_growth = category_sales_pivot.pct_change(axis='columns').iloc[:, 1:]

# Find the category with the highest sales growth rate across years
category_with_most_growth = category_sales_growth.mean().idxmax()

# Print the category with the most growth
print("Category with the most growth in terms of sales over the years:", category_with_most_growth)

"""# Customer Analysis"""

# Group by customer's email ID and calculate the number of orders placed and total sales generated for each customer
customer_orders = df.groupby('EmailID').agg({'Order ID': 'nunique', 'Sales': 'sum'}).reset_index()

# Rename columns for clarity
customer_orders.columns = ['EmailID', 'Number of Orders', 'Total Sales']

# Sort customers based on the number of orders placed and total sales generated
top_customers_orders = customer_orders.sort_values(by='Number of Orders', ascending=False).head(5)
top_customers_sales = customer_orders.sort_values(by='Total Sales', ascending=False).head(5)

print("Top 5 Customers based on the Number of Orders Placed:")
print(top_customers_orders)
print("\nTop 5 Customers based on Total Sales Generated:")
print(top_customers_sales)

# Plotting the number of orders placed by each of the top customers
plt.figure(figsize=(12, 6))
plt.bar(top_customers_orders['EmailID'], top_customers_orders['Number of Orders'], color='skyblue')
plt.title('Number of Orders Placed by Top Customers')
plt.xlabel('Customer Email ID')
plt.ylabel('Number of Orders')
plt.xticks(rotation=45)
plt.show()

# Plotting the total sales generated by each of the top customers
plt.figure(figsize=(12, 6))
plt.bar(top_customers_sales['EmailID'], top_customers_sales['Total Sales'], color='salmon')
plt.title('Total Sales Generated by Top Customers')
plt.xlabel('Customer Email ID')
plt.ylabel('Total Sales ($)')
plt.xticks(rotation=45)
plt.show()

# Scatter plot to explore the relationship between number of orders and total sales for top customers
plt.figure(figsize=(8, 6))
plt.scatter(customer_orders['Number of Orders'], customer_orders['Total Sales'], color='green')
plt.title('Relationship between Number of Orders and Total Sales for Top Customers')
plt.xlabel('Number of Orders')
plt.ylabel('Total Sales ($)')
plt.grid(True)
plt.show()

"""**Insights:**

**Frequency of Orders:** These customers place a high number of orders, indicating that they are regular buyers or frequent purchasers of products.

**Customer Loyalty:** High order frequency suggests that these customers have a strong relationship with the business and are likely to be loyal customers.

**Variety of Purchases:** Customers who place a large number of orders may have diverse buying behavior, purchasing products from different categories or making multiple transactions over time.

**Total Sales Generated:** Customers with the highest total sales may not necessarily have the highest number of orders, but they contribute significantly to the overall revenue of the business. Understanding their purchasing patterns and preferences can help tailor marketing strategies and product offerings to maximize sales and customer satisfaction.
"""

# Convert 'Order Date' to datetime format
df['Order Date'] = pd.to_datetime(df['Order Date'])

# Sort the DataFrame by 'EmailID' and 'Order Date'
df_sorted = df.sort_values(by=['EmailID', 'Order Date'])

# Calculate the time difference between consecutive orders for each customer
df_sorted['Time Between Orders'] = df_sorted.groupby('EmailID')['Order Date'].diff()

# Group the data by 'EmailID' and calculate the average time between orders for each customer
average_time_between_orders = df_sorted.groupby('EmailID')['Time Between Orders'].mean()

# Print the results
print("Average Time Between Orders for Each Customer:")
print(average_time_between_orders)

"""Customers with shorter average times between orders may exhibit higher levels of loyalty or engagement with the business. Conversely, customers with longer average times between orders may require targeted marketing efforts or incentives to encourage repeat purchases.





"""

# Plot a histogram of average time between orders
plt.figure(figsize=(10, 6))
plt.hist(average_time_between_orders.dropna().dt.days, bins=20, color='skyblue', edgecolor='black')
plt.title('Distribution of Average Time Between Orders')
plt.xlabel('Average Time Between Orders (days)')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

"""We can see that lesser Average Time Between Orders have more frquency of orders .

# Comprehensive Analysis

1.Optimizing the supply chain based on insights from sales velocity and order fulfillment data involves improving efficiency, reducing costs, and enhancing customer satisfaction. Here are some strategies that can be implemented:

**Demand Forecasting:** Utilize historical sales data and sales velocity trends to forecast future demand accurately. This can help in optimizing inventory levels, ensuring the right amount of stock is available to meet customer demand while minimizing excess inventory and associated carrying costs.

**Inventory Management:** Implement just-in-time (JIT) inventory management techniques to minimize inventory holding costs and improve inventory turnover. Monitor sales velocity and adjust inventory levels accordingly to avoid stockouts and overstock situations.

**Supplier Collaboration:** Collaborate closely with suppliers to streamline the supply chain process. Share sales velocity data and demand forecasts with suppliers to enable them to better plan production schedules and ensure timely delivery of raw materials or finished goods.

**Order Fulfillment Efficiency:** Optimize order fulfillment processes to reduce lead times and improve order accuracy. Implement automation and technology solutions such as barcode scanning, RFID tracking, and order management systems to streamline order processing and reduce errors.

2.The geographic distribution of sales can be influenced by various underlying factors, and understanding these factors is crucial for informing targeted marketing strategies. Here are some factors that contribute to the geographic distribution of sales and how insights from sales data can inform marketing strategies:

**Demographic and Socioeconomic Factors:**

Demographic characteristics such as age, gender, income level, education, and occupation can influence consumer behavior and purchasing preferences.

Socioeconomic factors such as urbanization, population density, and employment rates can also impact consumer spending patterns.

Insights from sales data can help identify regions with specific demographic profiles and tailor marketing messages and product offerings to resonate with the target audience in those regions.

**Market Demand and Preferences:**

Geographic variations in market demand and consumer preferences play a significant role in shaping sales patterns.

Analyzing sales data can reveal which products or categories are popular in different regions and identify opportunities to capitalize on existing demand or introduce new products tailored to local preferences.

3.Identifying the patterns with this much of know how is bit diificult , the data needs some machine learning concepts . The models will identify the patterns among the data.
We can use several machine learning models like Random Forest, Decesion Tree , Linear Regression.
"""

